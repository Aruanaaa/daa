#Assignment 1: Divide and Conquer Algorithms

Introduction
В этом проекте реализованы и проанализированы несколько классических алгоритмов по принципу divide-and-conquer. Основные цели работы были следующие:
- Реализовать алгоритмы с безопасным использованием рекурсии.
- Выполнить теоретический анализ времени работы с помощью Master Theorem и подхода Akra–Bazzi.
- Проверить результаты экспериментально и собрать метрики (время, глубина рекурсии, количество сравнений и выделений памяти).
- Оформить отчет и поддерживать чистую историю коммитов в GitHub.

Архитектура проекта
Структура проекта:

algorithms-project/  
├── src/main/java/com/algorithms/  
│    ├── Main.java  
│    ├── MergeSort.java  
│    ├── QuickSort.java  
│    ├── QuickSelect.java  
│    ├── ClosestPair.java  
│    └── utils/...  
├── src/test/java/com/algorithms/  
│    ├── MergeSortTest.java  
│    ├── QuickSortTest.java  
│    ├── QuickSelectTest.java  
│    └── ClosestPairTest.java  
├── scripts/  
│    ├── run_benchmarks.sh  
│    └── generate_plots.py  
├── .github/workflows/ci.yml  
└── README.md

Main.java является точкой входа для запуска и проверки.  
Отдельные файлы содержат реализации алгоритмов и сбор метрик.  
В директории test расположены тесты на JUnit5.  
В scripts находятся вспомогательные скрипты для бенчмарков и построения графиков.  
Файл ci.yml содержит настройку GitHub Actions для автоматической сборки и проверки.

Алгоритмы и анализ

MergeSort
Рекуррентное уравнение: T(n) = 2T(n/2) + Θ(n).  
Решение по Master Theorem (Case 2): T(n) = Θ(n log n).  
Алгоритм реализован с переиспользованием буфера для уменьшения выделений памяти.

QuickSort
Средний случай: T(n) = T(k) + T(n-k-1) + Θ(n), где k случайный.  
Ожидаемая сложность: Θ(n log n).  
Худший случай: Θ(n^2), но используется случайный выбор опорного элемента, что предотвращает деградацию.  
Дополнительно реализован принцип рекурсии сначала в меньший подмассив для ограничения глубины стека.

QuickSelect
Рекуррентное уравнение: T(n) = T(n/2) + Θ(n).  
Ожидаемая сложность: Θ(n).  
Алгоритм основан на случайном выборе опорного элемента, для проверки сравнивается с результатом Arrays.sort.

Closest Pair of Points
Рекуррентное уравнение: T(n) = 2T(n/2) + Θ(n log n).  
Сложность: Θ(n log n).  
Алгоритм делит множество по координате x и проверяет точки в узкой полосе по координате y.

Метрики и эксперименты
Все алгоритмы дополнены сбором метрик: время выполнения, глубина рекурсии, количество сравнений, количество выделений памяти.

Данные собираются при помощи скрипта:  
./scripts/run_benchmarks.sh

Результаты сохраняются в CSV. Для построения графиков используется Python-скрипт generate_plots.py.

Результаты
MergeSort показал ожидаемое поведение Θ(n log n), глубина рекурсии примерно равна log2(n).  
QuickSort в среднем случае также соответствует Θ(n log n), но на малых данных работает быстрее за счет кэширования. Глубина рекурсии в экспериментах около 1.5 log2(n).  
QuickSelect подтвердил линейную сложность и работает быстрее сортировки для выборки одного порядка.  
Closest Pair совпадает с результатами brute-force на малых n и показывает ожидаемую асимптотику Θ(n log n) на больших данных.

Заключение
Все алгоритмы были реализованы, протестированы и сопоставлены с теорией.  
Анализ с использованием Master Theorem и Akra–Bazzi подтвердился экспериментально.  
История коммитов оформлена в соответствии с заданием, добавлены метрики, тесты и CI.

Репозиторий 
https://github.com/YOUR_USERNAME/algorithms-project
